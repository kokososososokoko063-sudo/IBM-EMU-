<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super IBM 5150 Plus - Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bezel-color: #dcd6c8;
            --screen-black: #050505;
            --phosphor-main: #55ffff; 
            --phosphor-dim: #00aaaa;
            --phosphor-glow: rgba(85, 255, 255, 0.4);
        }

        .theme-green {
            --phosphor-main: #33ff00;
            --phosphor-dim: #1a8000;
            --phosphor-glow: rgba(51, 255, 0, 0.4);
        }
        .theme-amber {
            --phosphor-main: #ffb000;
            --phosphor-dim: #996a00;
            --phosphor-glow: rgba(255, 176, 0, 0.4);
        }
        .theme-white {
            --phosphor-main: #ffffff;
            --phosphor-dim: #888888;
            --phosphor-glow: rgba(255, 255, 255, 0.4);
        }

        * { box-sizing: border-box; }

        body {
            background-color: #080808;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'VT323', monospace;
            user-select: none;
            -webkit-user-select: none;
        }

        .monitor-casing {
            width: 95vw;
            max-width: 960px;
            aspect-ratio: 4/3;
            background-color: var(--bezel-color);
            border-radius: 20px;
            padding: 30px;
            position: relative;
            box-shadow: 
                inset 0 0 40px rgba(0,0,0,0.3),
                0 0 100px rgba(0,0,0,0.8),
                10px 10px 0px rgba(20,20,20,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s;
        }

        .badge-ibm {
            position: absolute;
            top: 15px;
            left: 30px;
            background: #222;
            color: #ccc;
            padding: 4px 12px;
            font-family: 'Courier New', serif;
            font-weight: bold;
            border-left: 4px solid #aaa;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 16px;
            letter-spacing: 1px;
            z-index: 10;
            text-transform: uppercase;
        }

        .screen-container {
            width: 100%;
            height: 82%;
            background: #000;
            border-radius: 5% / 5%;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 60px rgba(100,100,100,0.1);
            border: 15px solid #1a1a1a;
        }

        #crt-display {
            width: 100%;
            height: 100%;
            background-color: var(--screen-black);
            color: var(--phosphor-main);
            font-size: 1.4rem; 
            line-height: 1;
            white-space: pre;
            padding: 15px;
            text-shadow: 0 0 2px var(--phosphor-dim), 0 0 5px var(--phosphor-glow);
            font-family: 'VT323', monospace;
            overflow: hidden;
            cursor: default;
            display: grid;
            grid-template-rows: repeat(25, 1fr);
            grid-template-columns: repeat(80, 1fr);
            gap: 0;
            direction: ltr; 
        }

        @media (max-width: 800px) {
            #crt-display { font-size: 1rem; padding: 5px; }
            .monitor-casing { padding: 10px; width: 98vw; aspect-ratio: auto; height: 70vh; }
        }

        .char-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .char-cell.inverted {
            background-color: var(--phosphor-main);
            color: var(--screen-black);
            text-shadow: none;
        }

        .overlay-scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.7;
        }
        
        .overlay-glow {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.4) 90%);
            pointer-events: none;
            z-index: 9;
            animation: flicker 0.1s infinite;
        }

        @keyframes flicker { 0% { opacity: 0.97; } 100% { opacity: 1; } }

        .controls-panel {
            margin-top: auto;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            align-items: center;
            height: 60px;
            background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.1));
            border-radius: 0 0 15px 15px;
        }

        .brand-label {
            font-size: 12px;
            color: #666;
            font-weight: bold;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5);
        }

        .power-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .big-red-switch {
            width: 50px;
            height: 30px;
            background: #a00;
            border: 3px solid #600;
            cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), 2px 2px 2px rgba(0,0,0,0.3);
            position: relative;
            transition: all 0.1s;
        }
        .big-red-switch:active { transform: scale(0.95); background: #800; }
        .big-red-switch::after {
            content: 'I  O';
            color: #fff;
            font-size: 10px;
            position: absolute;
            top: -15px;
            left: 12px;
            font-family: sans-serif;
            color: #444;
        }

        .led-indicator {
            width: 12px; height: 12px;
            background: #311;
            border-radius: 50%;
            border: 1px solid #222;
            transition: 0.3s;
        }
        .led-indicator.on {
            background: #f00;
            box-shadow: 0 0 10px #f33;
        }

        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 400px;
            padding: 10px;
            gap: 10px;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .mobile-controls { display: grid; grid-template-columns: 1fr 1fr; }
            .monitor-casing { margin-bottom: 20px; }
            body { height: auto; padding: 20px 0; overflow-y: auto; }
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            background: #222;
            padding: 10px;
            border-radius: 10px;
        }
        .action-pad {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            background: #222;
            padding: 10px;
            border-radius: 10px;
        }

        .mob-btn {
            background: #444;
            color: #fff;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 15px 0;
            font-family: 'VT323';
            font-size: 20px;
            text-align: center;
            user-select: none;
            cursor: pointer;
        }
        .mob-btn:active { background: #666; border-color: #888; }
        #keyboard-trap { position: absolute; opacity: 0; top: -1000px; }

    </style>
</head>
<body>

    <div class="monitor-casing" id="casing">
        <div class="badge-ibm">IBM Personal Computer</div>
        
        <div class="screen-container" onclick="focusTrap()">
            <div class="overlay-scanlines"></div>
            <div class="overlay-glow"></div>
            <div id="crt-display"></div>
        </div>

        <div class="controls-panel">
            <div class="brand-label">5150 SYSTEM UNIT</div>
            <div class="power-group">
                <div style="font-size: 10px; color: #444; font-family: sans-serif;">POWER</div>
                <div class="led-indicator" id="power-led"></div>
                <div class="big-red-switch" onclick="toggleSystemPower()"></div>
            </div>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="d-pad">
            <div></div>
            <div class="mob-btn" onpointerdown="simulateKey('ArrowUp')">▲</div>
            <div></div>
            <div class="mob-btn" onpointerdown="simulateKey('ArrowLeft')">◄</div>
            <div class="mob-btn" onpointerdown="simulateKey('ArrowDown')">▼</div>
            <div class="mob-btn" onpointerdown="simulateKey('ArrowRight')">►</div>
        </div>
        <div class="action-pad">
            <div class="mob-btn" style="background:#522;" onpointerdown="simulateKey('Escape')">ESC</div>
            <div class="mob-btn" style="background:#252;" onpointerdown="simulateKey('Enter')">ENT</div>
            <div class="mob-btn" onpointerdown="simulateKey('Backspace')">DEL</div>
            <div class="mob-btn" onpointerdown="simulateKey(' ')">SPC</div>
            <div class="mob-btn" style="grid-column: span 2; background:#335;" onpointerdown="showKeyboard()">KEYBOARD</div>
        </div>
    </div>

    <input type="text" id="keyboard-trap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <script>
        // --- CONSTANTS ---
        const SCREEN_COLS = 80;
        const SCREEN_ROWS = 25;
        
        // --- SYSTEM STATE ---
        const System = {
            power: false,
            mode: 'OFF', 
            currentApp: null,
            inputBuffer: '',
            path: 'A:\\',
            screenBuffer: [], 
            cursor: { x: 0, y: 0, visible: true },
            blinkInterval: null,
            theme: 'blue'
        };

        // --- FILESYSTEM ---
        const FileSystem = {
            "README.TXT": "Super IBM 5150 Plus\n\nCOMMANDS:\n- ASM: 8088 Assembler (Supports BUILD)\n- WIN: Windows 1.0 GUI\n- SNAKE: Improved Snake Game\n- DRAW: Drawing Tool (Saves BMP)\n- MATRIX: Screen Saver\n- COLOR: Change Colors",
            "TEST.ASM": "; Counter Example\nMOV CX, 5\nSTART:\n  MOV AX, CX\n  INT 21 ; Print\n  DEC CX\n  CMP CX, 0\n  JNE START\nINT 20 ; Exit",
            "AUTOEXEC.BAT": "ECHO OFF\nCLS\nDATE",
        };

        const displayEl = document.getElementById('crt-display');
        const trap = document.getElementById('keyboard-trap');

        // --- SOUND ENGINE ---
        const Sound = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            
            init: function() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },

            beep: function(freq = 440, duration = 0.1, type = 'square') {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = 0.03;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playClick: function() {
                // Mechanical Keyboard Sound
                this.init();
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // High click
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(2000, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);
                
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.05);
            },

            playHDD: function() {
                // Mechanical HDD Seek Sound (Grinding noise)
                this.init();
                const t = this.ctx.currentTime;
                // Use a noise buffer logic or simplified multiple oscillators
                for(let i=0; i<3; i++) {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.type = 'sawtooth';
                        osc.frequency.value = 50 + Math.random() * 50;
                        gain.gain.value = 0.02;
                        osc.connect(gain);
                        gain.connect(this.ctx.destination);
                        osc.start();
                        osc.stop(this.ctx.currentTime + 0.03);
                    }, i * 40);
                }
            }
        };

        // --- CORE DISPLAY FUNCTIONS ---

        function initScreen() {
            displayEl.innerHTML = '';
            System.screenBuffer = [];
            for (let r = 0; r < SCREEN_ROWS; r++) {
                let row = [];
                for (let c = 0; c < SCREEN_COLS; c++) {
                    const span = document.createElement('span');
                    span.className = 'char-cell';
                    span.textContent = '\u00A0'; 
                    displayEl.appendChild(span);
                    row.push({ char: ' ', attr: 0, element: span });
                }
                System.screenBuffer.push(row);
            }
        }

        function clearScreen() {
            for (let r = 0; r < SCREEN_ROWS; r++) {
                for (let c = 0; c < SCREEN_COLS; c++) {
                    putChar(c, r, ' ');
                }
            }
            System.cursor.x = 0;
            System.cursor.y = 0;
        }

        function putChar(x, y, char, invert = false) {
            if (x < 0 || x >= SCREEN_COLS || y < 0 || y >= SCREEN_ROWS) return;
            const cell = System.screenBuffer[y][x];
            cell.char = char;
            cell.element.textContent = char === ' ' ? '\u00A0' : char;
            if (invert) cell.element.classList.add('inverted');
            else cell.element.classList.remove('inverted');
        }

        function print(text, newLine = true) {
            if (text === undefined || text === null) return;
            text = text.toString();
            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                if (char === '\n') {
                    newLineLogic();
                } else {
                    putChar(System.cursor.x, System.cursor.y, char);
                    System.cursor.x++;
                    if (System.cursor.x >= SCREEN_COLS) {
                        newLineLogic();
                    }
                }
            }
            if (newLine) newLineLogic();
        }

        function printAt(x, y, text, invert = false) {
            for (let i = 0; i < text.length; i++) {
                putChar(x + i, y, text[i], invert);
            }
        }

        function newLineLogic() {
            System.cursor.x = 0;
            System.cursor.y++;
            if (System.cursor.y >= SCREEN_ROWS) {
                scrollUp();
                System.cursor.y = SCREEN_ROWS - 1;
            }
        }

        function scrollUp() {
            for (let r = 0; r < SCREEN_ROWS - 1; r++) {
                for (let c = 0; c < SCREEN_COLS; c++) {
                    const curr = System.screenBuffer[r][c];
                    const next = System.screenBuffer[r+1][c];
                    curr.char = next.char;
                    curr.element.textContent = next.element.textContent;
                    if (next.element.classList.contains('inverted')) curr.element.classList.add('inverted');
                    else curr.element.classList.remove('inverted');
                }
            }
            for (let c = 0; c < SCREEN_COLS; c++) {
                putChar(c, SCREEN_ROWS - 1, ' ');
            }
        }

        function renderCursor() {
            if (!System.power) return;
            const cell = System.screenBuffer[System.cursor.y]?.[System.cursor.x];
            if (!cell) return;
            if (System.cursor.visible) {
                cell.element.classList.toggle('inverted');
            }
        }

        // --- SYSTEM POWER & BOOT ---
        function toggleSystemPower() {
            const led = document.getElementById('power-led');
            if (System.power) {
                // Shutdown
                System.power = false;
                System.mode = 'OFF';
                led.classList.remove('on');
                clearInterval(System.blinkInterval);
                displayEl.innerHTML = ''; 
                trap.blur();
                Sound.beep(100, 0.3, 'sawtooth');
            } else {
                // Boot
                initScreen();
                System.power = true;
                System.mode = 'BOOT';
                led.classList.add('on');
                focusTrap();
                Sound.playHDD();
                
                System.blinkInterval = setInterval(renderCursor, 500);
                bootSequence();
            }
        }

        async function bootSequence() {
            await delay(500);
            print("IBM Personal Computer BIOS v4.77");
            await delay(200);
            print("Copyright IBM Corp 1981, 1988");
            await delay(500);
            print("640 KB System RAM Passed");
            Sound.playHDD();
            await delay(800);
            print("Loading DOS...");
            Sound.beep(800, 0.1);
            await delay(1000);
            clearScreen();
            System.mode = 'DOS';
            print("IBM DOS Version 3.30");
            print("(C)Copyright IBM Corp 1981-1988");
            print("");
            prompt();
        }

        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        function prompt() { print(System.path + ">", false); }

        // --- INPUT HANDLING ---
        function focusTrap() {
            if(System.power) trap.focus();
        }

        window.simulateKey = function(key) {
            const event = new KeyboardEvent('keydown', { key: key });
            document.dispatchEvent(event);
        };

        document.addEventListener('keydown', (e) => {
            if (!System.power) return;
            focusTrap();
            if(e.key === 'Tab' || e.key === 'Alt') e.preventDefault();
            
            // Sound Effect
            if(e.key.length === 1 || e.key === 'Enter' || e.key === 'Backspace') Sound.playClick();

            if (System.currentApp) {
                System.currentApp.handleInput(e);
            } else if (System.mode === 'DOS') {
                handleDOSInput(e);
            }
        });

        function handleDOSInput(e) {
            const cell = System.screenBuffer[System.cursor.y][System.cursor.x];
            cell.element.classList.remove('inverted');

            if (e.key === 'Enter') {
                processCommand();
            } else if (e.key === 'Backspace') {
                if (System.inputBuffer.length > 0) {
                    System.inputBuffer = System.inputBuffer.slice(0, -1);
                    System.cursor.x--;
                    putChar(System.cursor.x, System.cursor.y, ' ');
                }
            } else if (e.key.length === 1 && !e.ctrlKey) {
                System.inputBuffer += e.key;
                print(e.key, false);
            }
        }

        // --- DOS SHELL ---
        function processCommand() {
            const cmdLine = System.inputBuffer.trim();
            System.inputBuffer = '';
            print(""); 

            if (!cmdLine) { prompt(); return; }

            // Parse: command arg1 arg2 ...
            // Handle filenames with spaces if needed, but keeping simple for now
            const parts = cmdLine.split(' ');
            const cmd = parts[0].toUpperCase();
            
            // Arguments handling (re-joining for things like BUILD file.asm out.exe)
            const args = parts.slice(1);

            // Check for Executables First (Virtual EXE/COM)
            if (cmd.endsWith('.EXE') || cmd.endsWith('.COM')) {
                if (FileSystem[cmd] && FileSystem[cmd].startsWith("$$EXE$$")) {
                    launchApp(new EXEApp(FileSystem[cmd]));
                    return;
                }
            }

            switch (cmd) {
                case 'CLS': clearScreen(); break;
                case 'DIR': listFiles(); break;
                case 'DEL': deleteFile(args[0]); break;
                case 'COLOR': changeTheme(args[0]); break;
                case 'MATRIX': launchApp(new MatrixApp()); break;
                case 'DRAW': launchApp(new DrawApp()); break;
                case 'SNAKE': launchApp(new SnakeApp()); break;
                case 'DB': launchApp(new DBApp()); break;
                case 'CALC': launchApp(new CalcApp()); break;
                case 'EDIT': launchApp(new EditApp(args[0])); break;
                case 'ASM': launchApp(new AsmApp(args)); break;
                case 'WIN': launchApp(new WindowsApp()); break;
                case 'TYPE': 
                    if(FileSystem[args[0]]) print(FileSystem[args[0]]); 
                    else print("File not found");
                    break;
                case 'VER': print("IBM Personal Computer DOS Version 3.30"); break;
                default:
                    // Check if it's an ASM file the user wants to run or edit
                    if (FileSystem[cmd]) {
                         print("Bad command or filename. (If executable, ensure .EXE extension)");
                    } else {
                        print("Bad command or file name");
                    }
            }

            if (!System.currentApp) prompt();
        }

        function listFiles() {
            print(" Volume in drive A is SUPER_PC");
            print(" Directory of A:\\");
            print("");
            let count = 0;
            Sound.playHDD();
            for (let f in FileSystem) {
                let size = FileSystem[f].length;
                let spaces = " ".repeat(Math.max(1, 14 - f.length));
                print(` ${f}${spaces}${size}`);
                count++;
            }
            print(`        ${count} File(s)`);
        }

        function deleteFile(filename) {
            if (!filename) { print("Error: Missing filename"); return; }
            filename = filename.toUpperCase();
            if (FileSystem[filename]) {
                delete FileSystem[filename];
                Sound.playHDD();
                print("File deleted.");
            } else {
                print("File not found.");
            }
        }

        function changeTheme(color) {
            if(!color) return;
            color = color.toUpperCase();
            const casing = document.getElementById('casing');
            casing.classList.remove('theme-green', 'theme-amber', 'theme-white');
            if (color === 'GREEN') casing.classList.add('theme-green');
            else if (color === 'AMBER') casing.classList.add('theme-amber');
            else if (color === 'WHITE') casing.classList.add('theme-white');
            print(`Theme changed to ${color}`);
        }

        function launchApp(app) {
            System.currentApp = app;
            System.mode = 'APP';
            clearScreen();
            app.init();
        }

        function closeApp() {
            System.currentApp = null;
            System.mode = 'DOS';
            clearScreen();
            prompt();
        }

        // ==========================================
        //  APP: WINDOWS 1.0 (GUI Simulation)
        // ==========================================
        class WindowsApp {
            constructor() {
                this.mouseX = 40;
                this.mouseY = 12;
            }
            init() {
                this.drawDesktop();
                this.drawWindow(10, 5, 60, 15, "MS-DOS Executive");
                printAt(12, 8, "A:\\", true);
                printAt(12, 10, "CALC.EXE");
                printAt(12, 11, "REVERSI.EXE");
                printAt(12, 12, "WRITE.EXE");
            }
            drawDesktop() {
                for(let r=0; r<SCREEN_ROWS; r++) {
                    for(let c=0; c<SCREEN_COLS; c++) {
                        putChar(c, r, '░');
                    }
                }
                // Menu Bar
                printAt(0, 0, " ".repeat(SCREEN_COLS), true);
                printAt(2, 0, "File  View  Special", true);
            }
            drawWindow(x, y, w, h, title) {
                // Drop shadow
                for(let i=1; i<h; i++) printAt(x+w, y+i, "▓");
                for(let i=1; i<w; i++) printAt(x+i, y+h, "▓");
                
                // Window Body
                for(let i=0; i<h; i++) {
                    printAt(x, y+i, " ".repeat(w));
                }
                // Title Bar
                printAt(x, y, " ".repeat(w), true);
                printAt(x + (w-title.length)/2, y, title, true);
                printAt(x+1, y, "[=]", true);
            }
            handleInput(e) {
                if (e.key === 'Escape') closeApp();
                // Move "Mouse"
                if (e.key.startsWith('Arrow')) {
                    const oldX = this.mouseX; const oldY = this.mouseY;
                    // Restore background char at old pos (simplified)
                    
                    if (e.key === 'ArrowUp') this.mouseY--;
                    if (e.key === 'ArrowDown') this.mouseY++;
                    if (e.key === 'ArrowLeft') this.mouseX--;
                    if (e.key === 'ArrowRight') this.mouseX++;
                    
                    // Simple cursor render
                    putChar(this.mouseX, this.mouseY, '↖', true);
                }
            }
        }

        // ==========================================
        //  APP: SNAKE (IMPROVED)
        // ==========================================
        class SnakeApp {
            constructor() {
                this.snake = [{x: 40, y: 12}, {x:39, y:12}, {x:38, y:12}];
                this.dir = {x: 1, y: 0};
                this.food = {x: 10, y: 10};
                this.score = 0;
                this.gameOver = false;
                this.timer = null;
            }
            init() {
                this.spawnFood();
                this.timer = setInterval(() => this.update(), 100);
            }
            spawnFood() {
                do {
                    this.food = {
                        x: 2 + Math.floor(Math.random() * (SCREEN_COLS - 4)),
                        y: 2 + Math.floor(Math.random() * (SCREEN_ROWS - 4))
                    };
                } while (this.snake.some(s => s.x === this.food.x && s.y === this.food.y));
            }
            update() {
                if (this.gameOver) return;
                let head = {x: this.snake[0].x + this.dir.x, y: this.snake[0].y + this.dir.y};

                // Border Collision
                if (head.x < 1 || head.x >= SCREEN_COLS-1 || head.y < 1 || head.y >= SCREEN_ROWS-1 ||
                    this.snake.some(s => s.x === head.x && s.y === head.y)) {
                    this.endGame(); return;
                }

                this.snake.unshift(head);
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    Sound.beep(1200, 0.05);
                    this.spawnFood();
                } else {
                    this.snake.pop();
                }
                this.draw();
            }
            draw() {
                clearScreen();
                // Draw Border
                for(let c=0; c<SCREEN_COLS; c++) { putChar(c, 0, '═'); putChar(c, SCREEN_ROWS-1, '═'); }
                for(let r=0; r<SCREEN_ROWS; r++) { putChar(0, r, '║'); putChar(SCREEN_COLS-1, r, '║'); }
                putChar(0,0,'╔'); putChar(SCREEN_COLS-1,0,'╗'); 
                putChar(0,SCREEN_ROWS-1,'╚'); putChar(SCREEN_COLS-1,SCREEN_ROWS-1,'╝');

                // Draw Score
                printAt(2, 0, ` SCORE: ${this.score} `, true);

                // Draw Food
                putChar(this.food.x, this.food.y, '♥');
                // Draw Snake
                this.snake.forEach((s) => putChar(s.x, s.y, '█'));
            }
            endGame() {
                this.gameOver = true;
                clearInterval(this.timer);
                printAt(35, 12, " GAME OVER ", true);
                printAt(32, 13, " Press ESC to Exit ");
                Sound.beep(100, 0.5, 'sawtooth');
            }
            handleInput(e) {
                if (e.key === 'Escape') { clearInterval(this.timer); closeApp(); }
                if (e.key === 'ArrowUp' && this.dir.y === 0) this.dir = {x: 0, y: -1};
                if (e.key === 'ArrowDown' && this.dir.y === 0) this.dir = {x: 0, y: 1};
                if (e.key === 'ArrowLeft' && this.dir.x === 0) this.dir = {x: -1, y: 0};
                if (e.key === 'ArrowRight' && this.dir.x === 0) this.dir = {x: 1, y: 0};
            }
        }

        // ==========================================
        //  APP: DRAW (Saves to simulated BMP)
        // ==========================================
        class DrawApp {
            constructor() {
                this.x = 40; this.y = 12;
                this.penDown = false;
                this.char = '█';
                this.chars = ['█', '▓', '▒', '░', '*', '#', '@', '+', '.', 'X'];
                this.idx = 0;
            }
            init() {
                printAt(0, 0, "DRAW: ARROWS=Move SPC=Pen 'C'=Change 'S'=Save BMP ESC=Exit", true);
            }
            handleInput(e) {
                if (e.key === 'Escape') closeApp();
                if (e.key === 'ArrowUp') this.y = Math.max(1, this.y - 1);
                if (e.key === 'ArrowDown') this.y = Math.min(SCREEN_ROWS - 1, this.y + 1);
                if (e.key === 'ArrowLeft') this.x = Math.max(0, this.x - 1);
                if (e.key === 'ArrowRight') this.x = Math.min(SCREEN_COLS - 1, this.x + 1);
                
                if (e.key === ' ') {
                    this.penDown = !this.penDown;
                    Sound.beep(this.penDown ? 600 : 300, 0.05);
                }
                if (e.key.toUpperCase() === 'C') {
                    this.idx = (this.idx + 1) % this.chars.length;
                    this.char = this.chars[this.idx];
                    printAt(60, 0, `Char:${this.char}`, true);
                }
                if (e.key.toUpperCase() === 'S') {
                    this.saveBMP();
                }

                if (this.penDown) putChar(this.x, this.y, this.char);
                System.cursor.x = this.x; System.cursor.y = this.y;
            }
            saveBMP() {
                // Serialize screen buffer
                let data = "TYPE:BMP\n";
                for(let r=1; r<SCREEN_ROWS; r++) { // Skip header
                    let line = "";
                    for(let c=0; c<SCREEN_COLS; c++) {
                        line += System.screenBuffer[r][c].char;
                    }
                    data += line + "\n";
                }
                FileSystem["IMAGE.BMP"] = data;
                Sound.playHDD();
                printAt(50, 0, "SAVED IMAGE.BMP", true);
            }
        }

        // ==========================================
        //  APP: ASSEMBLER 2.0 (True 8088 Sim)
        // ==========================================
        
        // Virtual CPU Class
        class CPU8088 {
            constructor() {
                this.regs = { AX:0, BX:0, CX:0, DX:0, SI:0, DI:0, SP: 100, BP:0, IP:0 };
                this.flags = { Z: false, S: false, O: false };
                this.stack = new Array(256).fill(0);
                this.program = []; // Array of instruction objects
                this.labels = {};  // Map Label -> Instruction Index
                this.output = [];
            }

            reset() {
                this.regs = { AX:0, BX:0, CX:0, DX:0, SI:0, DI:0, SP: 100, BP:0, IP:0 };
                this.flags = { Z: false, S: false };
                this.output = [];
            }

            load(compiledObj) {
                this.program = compiledObj.code;
                this.labels = compiledObj.labels;
                this.reset();
            }

            step() {
                if (this.regs.IP >= this.program.length) return false; // Halted
                
                const instr = this.program[this.regs.IP];
                this.regs.IP++; // Default advance
                
                try {
                    this.execute(instr);
                    return true;
                } catch(e) {
                    this.output.push("RUNTIME ERR: " + e.message);
                    return false;
                }
            }

            getVal(op) {
                if (typeof op === 'number') return op;
                if (this.regs[op] !== undefined) return this.regs[op];
                throw new Error("Invalid operand: " + op);
            }

            setVal(dest, val) {
                if (this.regs[dest] !== undefined) this.regs[dest] = val;
                // else ignore or error
            }

            execute(instr) {
                const op = instr.op;
                const a1 = instr.args[0];
                const a2 = instr.args[1];

                switch(op) {
                    case 'MOV': this.setVal(a1, this.getVal(a2)); break;
                    case 'ADD': this.setVal(a1, this.getVal(a1) + this.getVal(a2)); break;
                    case 'SUB': 
                        let res = this.getVal(a1) - this.getVal(a2);
                        this.setVal(a1, res);
                        this.flags.Z = (res === 0);
                        this.flags.S = (res < 0);
                        break;
                    case 'INC': this.setVal(a1, this.getVal(a1) + 1); break;
                    case 'DEC': 
                        let dec = this.getVal(a1) - 1;
                        this.setVal(a1, dec);
                        this.flags.Z = (dec === 0);
                        break;
                    case 'CMP':
                        let cmp = this.getVal(a1) - this.getVal(a2);
                        this.flags.Z = (cmp === 0);
                        this.flags.S = (cmp < 0);
                        break;
                    case 'JMP': 
                        if (this.labels[a1] !== undefined) this.regs.IP = this.labels[a1]; 
                        break;
                    case 'JE':  if (this.flags.Z) this.regs.IP = this.labels[a1]; break;
                    case 'JNE': if (!this.flags.Z) this.regs.IP = this.labels[a1]; break;
                    case 'JG':  if (!this.flags.S && !this.flags.Z) this.regs.IP = this.labels[a1]; break;
                    case 'JL':  if (this.flags.S) this.regs.IP = this.labels[a1]; break;
                    
                    case 'INT':
                        if (a1 == 20) this.regs.IP = this.program.length; // Exit
                        if (a1 == 21) this.output.push(`${this.regs.AX}`); // Simple print
                        break;
                }
            }
        }

        // Assembler App (Editor & Compiler)
        class AsmApp {
            constructor(args) {
                this.filename = args[0] || null;
                this.buildTarget = (args[1] === 'BUILD') ? args[2] : null;
                this.lines = [];
                this.status = "MODE: EDITOR (F2: RUN | F4: BUILD)";
                
                // If opening file
                if (this.filename && FileSystem[this.filename]) {
                    this.lines = FileSystem[this.filename].split('\n');
                } else if (this.filename) {
                    this.lines = ["; New ASM File", ""];
                } else {
                    this.lines = ["; Interactive Mode", "MOV AX, 1", "ADD AX, 2", "INT 21", "INT 20"];
                }
                this.cy = 0; this.cx = 0;
            }

            init() {
                // If command was "ASM file.asm BUILD out.exe"
                if (this.filename && this.buildTarget) {
                    this.compileAndLink(this.buildTarget);
                    closeApp();
                    return;
                }
                // Else open editor
                this.render();
            }

            compile(sourceLines) {
                const code = [];
                const labels = {};
                let ptr = 0;

                // Pass 1: Labels & Parsing
                for (let line of sourceLines) {
                    // Remove comments
                    line = line.split(';')[0].trim();
                    if (!line) continue;

                    if (line.endsWith(':')) {
                        labels[line.slice(0, -1)] = ptr;
                        continue;
                    }

                    const parts = line.replace(',', ' ').split(/\s+/);
                    const op = parts[0].toUpperCase();
                    const args = parts.slice(1).map(a => {
                        return isNaN(parseInt(a)) ? a : parseInt(a);
                    });

                    code.push({ op, args });
                    ptr++;
                }

                return { code, labels };
            }

            compileAndLink(targetName) {
                try {
                    const binary = this.compile(this.lines);
                    // Add .EXE if missing
                    if(!targetName.toUpperCase().endsWith('.EXE') && !targetName.toUpperCase().endsWith('.COM')) {
                        targetName += ".EXE";
                    }
                    // Save as "Executable" JSON string
                    FileSystem[targetName.toUpperCase()] = "$$EXE$$" + JSON.stringify(binary);
                    print(`Bound ${targetName} successfully.`);
                    Sound.playHDD();
                } catch(e) {
                    print("Build Error: " + e.message);
                }
            }

            runImmediate() {
                clearScreen();
                print("--- ASM OUTPUT ---");
                try {
                    const cpu = new CPU8088();
                    const bin = this.compile(this.lines);
                    cpu.load(bin);
                    
                    let cycles = 0;
                    while(cpu.step() && cycles < 1000) { cycles++; } // Limit cycles to prevent freeze
                    
                    cpu.output.forEach(l => print(l));
                    print("--- EXEC FINISHED ---");
                } catch(e) {
                    print("ERR: " + e.message);
                }
                print("Press ANY KEY to return.");
                this.waiting = true;
            }

            render() {
                clearScreen();
                printAt(0, 0, `ASM EDITOR: ${this.filename || "Untitled"}  ${this.status}`, true);
                for(let i=0; i<Math.min(23, this.lines.length); i++) {
                    printAt(0, i+1, this.lines[i]);
                }
                System.cursor.x = this.cx;
                System.cursor.y = this.cy + 1;
            }

            handleInput(e) {
                if (this.waiting) { this.waiting = false; this.render(); return; }

                if (e.key === 'F2') { this.runImmediate(); return; }
                if (e.key === 'F4') { 
                    if(this.filename) {
                        FileSystem[this.filename] = this.lines.join('\n'); // Save Source
                        let exeName = this.filename.split('.')[0] + ".EXE";
                        this.compileAndLink(exeName);
                        this.status = `Built ${exeName}!`;
                        this.render();
                    } else {
                        this.status = "Save file first!";
                        this.render();
                    }
                    return; 
                }
                if (e.key === 'Escape') { closeApp(); return; }
                
                // Editor Logic
                if(e.key === 'ArrowUp') { this.cy = Math.max(0, this.cy-1); this.cx = Math.min(this.cx, this.lines[this.cy].length); }
                else if(e.key === 'ArrowDown') { if(this.cy < this.lines.length-1) this.cy++; this.cx = Math.min(this.cx, this.lines[this.cy].length); }
                else if(e.key === 'ArrowLeft') this.cx = Math.max(0, this.cx-1);
                else if(e.key === 'ArrowRight') this.cx = Math.min(this.lines[this.cy].length, this.cx+1);
                else if(e.key === 'Enter') {
                    const l = this.lines[this.cy];
                    this.lines[this.cy] = l.substring(0, this.cx);
                    this.lines.splice(this.cy+1, 0, l.substring(this.cx));
                    this.cy++; this.cx = 0;
                }
                else if(e.key === 'Backspace') {
                    if(this.cx > 0) {
                        const l = this.lines[this.cy];
                        this.lines[this.cy] = l.slice(0, this.cx-1) + l.slice(this.cx);
                        this.cx--;
                    } else if(this.cy > 0) {
                        this.cx = this.lines[this.cy-1].length;
                        this.lines[this.cy-1] += this.lines[this.cy];
                        this.lines.splice(this.cy, 1);
                        this.cy--;
                    }
                }
                else if(e.key.length === 1) {
                    const l = this.lines[this.cy];
                    this.lines[this.cy] = l.slice(0, this.cx) + e.key + l.slice(this.cx);
                    this.cx++;
                }
                this.render();
            }
        }

        // Executor for compiled EXE files
        class EXEApp {
            constructor(fileContent) {
                this.binData = JSON.parse(fileContent.substring(7));
            }
            init() {
                print("Loading executable into memory...");
                try {
                    const cpu = new CPU8088();
                    cpu.load(this.binData);
                    let cycles = 0;
                    while(cpu.step() && cycles < 2000) { cycles++; }
                    cpu.output.forEach(l => print(l));
                } catch(e) {
                    print("Program crashed: " + e.message);
                }
                Sound.beep(440, 0.2);
                print("");
                print("Program terminated.");
                print("Press ESC.");
            }
            handleInput(e) {
                if(e.key === 'Escape') closeApp();
            }
        }

        // ==========================================
        //  OTHER APPS
        // ==========================================
        class MatrixApp {
            constructor() {
                this.drops = [];
                for(let i=0; i<SCREEN_COLS; i++) this.drops[i] = Math.random() * -50;
                this.timer = null;
                this.chars = "010101XYZAOB@#$%^&*";
            }
            init() { this.timer = setInterval(() => this.update(), 50); }
            update() {
                for (let i = 0; i < this.drops.length; i++) {
                    const char = this.chars[Math.floor(Math.random() * this.chars.length)];
                    const y = Math.floor(this.drops[i]);
                    if (y >= 0 && y < SCREEN_ROWS) {
                        putChar(i, y, char, true); 
                        if (y > 0) putChar(i, y - 1, System.screenBuffer[y-1][i].char, false);
                    }
                    this.drops[i]++;
                    if (this.drops[i] > SCREEN_ROWS && Math.random() > 0.95) this.drops[i] = 0;
                }
            }
            handleInput(e) { clearInterval(this.timer); closeApp(); }
        }

        class CalcApp {
            constructor() { this.input = ""; this.result = ""; }
            init() { this.render(); }
            render() {
                clearScreen();
                printAt(25, 5, "==============================");
                printAt(25, 6, "|      BASIC CALCULATOR      |");
                printAt(25, 7, "==============================");
                printAt(25, 9, ` IN : ${this.input}`);
                printAt(25, 11,` OUT: ${this.result}`, true);
            }
            handleInput(e) {
                if (e.key === 'Escape') closeApp();
                else if (e.key === 'Enter') {
                    try { this.result = eval(this.input); } catch { this.result = "ERR"; }
                    this.input = ""; this.render();
                } else if (e.key === 'Backspace') {
                    this.input = this.input.slice(0, -1); this.render();
                } else if ("0123456789+-*/.()".includes(e.key)) {
                    this.input += e.key; this.render();
                }
            }
        }
        
        class DBApp {
            constructor() { this.records = [{name: "JOHN", age: "25"}, {name: "JANE", age: "30"}]; }
            init() { this.render(); }
            render() {
                clearScreen();
                printAt(0, 0, "DB APP - [ESC] EXIT");
                this.records.forEach((r,i) => printAt(0, 2+i, `${r.name} - ${r.age}`));
            }
            handleInput(e) { if(e.key === 'Escape') closeApp(); }
        }

        class EditApp extends AsmApp {
            init() { this.render(); } // Uses same editor logic as ASM but no compile
        }

    </script>
</body>
</html>
